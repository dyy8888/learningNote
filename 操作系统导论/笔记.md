## 第六章、机制：受限直接执行

操作系统必须以高性能的方式虚拟化CPU，同时保持对CPU的控制，因此需要硬件和操作系统支持。

### 6.1基础版本：受限直接执行

直接在CPU上运行我们的程序。操作系统会按照如下的步骤进行程序执行：

| 操作系统                                                     | 程序                          |
| :----------------------------------------------------------- | :---------------------------- |
| 在进程列表上创建条目；为程序分配内存；将程序加载到内存中；根据argc/argv设置程序栈 |                               |
| 清除寄存器，执行call main()方法                              |                               |
|                                                              | 执行main();从main中执行return |
| 释放进程的内存将进程从进程列表中删除                         |                               |

这么操作的问题：1.程序可能做坏事；2.程序在运行，如何让其停下来切换其他进程，确保虚拟化CPU的时分共享

### 6.2 问题1：受限制的操作

硬件提供两种执行模式协助操作系统：1.用户模式，程序不能完全访问硬件资源；2.内核模式，操作系统可以访问机器的全部资源。

进程要是想访问硬件资源，需要执行系统调用，程序需要执行特殊的陷阱（trap）指令。进入内核模式，完成相关工作后，操作系统调用一个特殊的从陷阱返回指令。

细节：trap如何知道在os中运行哪些代码？内核通过在启动时设置陷阱表（trap table）来实现（开机自动配置）

| 操作系统@启动（内核模式）                                    | 硬件                                                       |                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------------- | ----------------------------------------------- |
| 初始化陷阱表                                                 |                                                            |                                                 |
|                                                              | 记住系统调用处理程序地址                                   |                                                 |
| 操作系统@运行（内核模式）                                    | 硬件                                                       | 程序（应用模式）                                |
| 在进程列表上创建条目；为程序分配内存；将程序加载到内存中；根据argv设置程序栈；用寄存器/程序计数器填充内核栈；从陷阱返回 |                                                            |                                                 |
|                                                              | 从内核栈恢复寄存器转向用户模式跳到main                     |                                                 |
|                                                              |                                                            | 运行main  ......     调用系统调用；陷入操作系统 |
|                                                              | 将寄存器保存到内核栈；转向内核模式；跳到陷阱处理程序       |                                                 |
| 处理陷阱；做系统调用的工作；从陷阱返回                       |                                                            |                                                 |
|                                                              | 从内核栈恢复寄存器；转向用户模式；跳到陷阱之后的程序计数器 |                                                 |
|                                                              |                                                            | ......从main返回；陷入（通过exit()）            |
| 释放进程的内存将进程从进程列表中清除                         |                                                            |                                                 |

### 6.3 问题2：在进程中切换

一个进程在CPU上运行，那么os就没有运行，那么os又如何执行进程切换呢？所以关键问题就是如何让os重新获得CPU的控制权。

协作方式（等待系统调用）：运行时间过长的进程被假定会定期放弃CPU。如果程序执行了非法操作，比如以0为除数，那么就会陷入trap操作系统，操作系统重新获取CPU。

问题：如果进程处于死循环，不进行系统调用返还CPU控制权，那该怎么办？

回答：没办法，重启计算机了只能

非协作方式（操作系统进行控制）：关键点就是如何在没有协作的情况下获得控制权——时钟中断。利用时钟中断，让os重新获取CPU的控制权。

保存和恢复上下文：os重新获取CPU，那么是继续运行当前进程还是切换进程呢？由调度程序做出，它是os的一部分。如果决定切换，os会执行底层代码，即上下文切换（os为当前正在执行的进程保存一些寄存器的值，并为即将执行的进程恢复一些寄存器的值）。

| 操作系统@启动（内核模式）                                    | 硬件                                                         |                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| 初始化陷阱表                                                 |                                                              |                  |
|                                                              | 记住以下地址：系统调用处理程序；时钟处理程序                 |                  |
| 启动中断时钟                                                 |                                                              |                  |
|                                                              | 启动时钟，每隔xms中断CPU                                     |                  |
| 操作系统@运行（内核模式）                                    | 硬件                                                         | 程序（应用模式） |
|                                                              |                                                              | 进程A......      |
|                                                              | 时钟中断；将寄存器A保存到内核栈A；转向内核模式；跳到陷阱处理程序 |                  |
| 处理陷阱；调用switch()例程：将寄存器A保存到进程结构A，将进程结构B恢复到寄存器B；从陷阱返回（进入B） |                                                              |                  |
|                                                              | 从内核栈B恢复寄存器B；转向用户模式；跳到B的程序计数器        |                  |
|                                                              |                                                              | 进程B......      |

## 第七章 进程调度：介绍

##### 度量指标：

周转时间=任务完成时间-任务到达时间

响应时间=首次运行时间-到达时间

##### 调度策略：

1.最短任务优先（SJF）：任务A：100s，B：10s，C：10s,那么优先执行任务B和C

2.最短完成时间优先（STCF）：加入抢断机制，A正在执行中，B和C来了，那么抢断执行B和C，

3.轮转（RR）：利用时间切片进行轮转

## 第八章 调度：多级反馈队列
MLFQ规则：

规则1：如果A的优先级>B的优先级，运行A（不运行B）

规则2：如果A的优先级=B的优先级，轮转运行A和B

规则3：工作进入系统时，放在最高优先级（最上层队列）

规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）

规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列

## 第九章 调度：比例份额

比例份额（彩票）调度方式内涵思想是随机性。根据进程所持彩票数占总体的比例，赋予执行的概率。还包括彩票转让机制（进程可以将彩票交付给其他进程）和彩票通胀。

彩票调度：彩票数(ticket)代表了进程(或用户或其他)占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。通过不断定时地(比如，每个时间片)抽取彩票，彩票调度从概率上(但不是确定的)获得这种份额比例。

步长调度：步长调度也很简单。系统中的每个工作都有自己的步长，这个值与票数值成反比。在 上面的例子中，A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。每次进程运行后，我们会让它的计数器 [称为行程(pass)值] 增加它的步长，记录它的总体进展。

## 第十三章 抽象：地址空间

一个进程的地址空间包含运行的程序的所有内存状态。例如：程序代码；当程序在运行的时候，利用栈(stack)来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。堆(heap)用于管理动态分配的、用户管理的内存（调用new获得的内存，静态初始化变量）。

虚拟内存系统负责为程序提供一 个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址但获取所需的信息。操作系统会同时对许多进程执行此操作，并且确保程序之间互相不会受到影响，也不会影响操作系统。

## 第十四章 内存操作API
内存包括堆和栈两种形式，程序运行需要内存的分配和释放两个步骤，在哪一步出错都可能导致程序的崩溃。

一般来说，系统中实际存在两级内存管理：

第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出(或以其他方式结束)时将其回收。

第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()(并因此泄露了堆中的内存)，操作系统也会在程序结束运行时，收回进程的所有内存(包括用于代码、栈，以及相关堆的内存页)。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。

## 第十五章 机制：地址转换

在实现CPU虚拟化的时候，一般准则为受限直接访问（LDE）。LDE 背后的想法很简单：让程序运行的大部分指令直接访问硬件，只在一些关键点(如进程发起系统调用或发生时钟中断)由操作系统介入来确保“在正确时间， 正确的地点，做正确的事”。

为了实现高效的虚拟化，操作系统应该尽量让程序自己运行， 同时通过在关键点的及时介入(interposing)，来保持对硬件的控制。高效和控制是现代操作系统的两个主要目标。
将虚拟地址转换为物理地址，这正是所谓的地址转换(address translation)技术。

这种地址转换实现的方式是动态重定位，首先，CPU需要两个寄存器：基址寄存器，界限寄存器。

基址寄存器通过记录基址，当程序计数器（例如128）被设置后，硬件获取这个地址后，就加上基址寄存器里的值（例如是32kb：32768），最终得到实际的物理地址32896。

界限寄存器提供访问保护，当进程访问超过边界或者访问负的虚拟地址时，CPU就会触发异常。

基址寄存器配合界限寄存器的硬件结构是芯片中的（每个CPU一对），我们将CPU负责地址转换的部分称为内存管理单元（MMU）

除此之外，操作系统还需要记录哪些空闲内存没有使用，我们使用空闲列表（free list）来实现。

操作系统在内核模式下可以通过特权指令修改这两个寄存器。操作系统和硬件进行配合，实现了简单的虚拟内存。

操作系统介入的过程：

创建进程时，为进程的地址空间找到内存空间（利用空闲列表标记空闲或已经使用）
进程中止时，操作系统回收内存，更新空闲列表
切换进程时，操作系统保存当前两个寄存器的值（保存在进程控制块PCB中）
异常发生时，操作系统提供应急行动
重定位会发生内存资源浪费的情况，因为被界限寄存器保护起来的内存无法被其他进程访问，如果这个进程使用的内存很少，资源就浪费了，所以要引入分段的概念。

## 第十六章 分段

分段可以更高效的虚拟内存，避免了地址空间中的逻辑段之间的内存浪费，而且算法实现很容易，可以实现代码共享的功能。

用15节里面的例子可能存在栈和堆之间的空间没有被使用却占用了大量内存的问题，将进程分为代码段，栈段，堆段，分别将之放到不同的物理内存上，，这样就避免了虚拟地址空间中未使用部分占用物理内存。
进行分段之后，仍然需要确认当前的地址引用的是哪个段，可以使用显式方式，用虚拟地址的开头几位来表示不同的段，例如前两位00，01，10，11分别对应代码段，栈段，堆段；有时也用一位来判断（堆，栈当作一位）

栈的处理方式特殊些，它的增长方式是反向的，段寄存器中有一个专门的字段记录是否反向增长。除此之外，各个段之间有时为了提高效率还要进行地址空间的共享，所以在段寄存器中又加入了保护信息，来判断代码段的权限。

加入保护信息后，界限寄存器功能需要升级，不仅需要检查虚拟地址是否越界，还需要检查特定访问是否允许。

分段执行之后，在物理内存中会存在很多较小的未分配内容的空间，这样会造成很大的资源浪费，虽然可以使用紧凑物理内存，最接近匹配，最坏匹配，首次匹配等等方法缩小这种资源浪费，但是无法完全解决这个问题，所以要引入分片。

## 第十七章 空闲空间管理

基本策略：

最优匹配：遍历整个空闲列表，找到最接近的空闲块
最差匹配：遍历后找到最大的空闲块
首次匹配：找到第一个足够大的块
下次匹配：首次匹配的策略下加入指针，指向上次查找结束的位置，为了将空闲空间的查找操作分散在整个地址空间
离奇的策略：

分离空闲列表：将一部分内存拿出来专门满足某种大小的请求，碎片就不会再成为问题了。这种方法省去了列表查找过程，特定大小的内存分配和释放都很快

伙伴系统：将空闲空间递归的一分为二，知道刚好可以满足请求，这种方法优秀在内存释放时，直接向上合并就可以了。
